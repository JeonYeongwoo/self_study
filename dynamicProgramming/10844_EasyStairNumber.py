# 10844 백준 쉬운 계단 수 문제
# ================== 풀이 ========================
# dp[0]~ dp [9]짜리 100개 생성한다.
# 0~9번째 총 9개로 시작하는 걸 생성하되, 0으로 시작하는것은 제외하므로
# 답을 낼 때는 1~9번만 더하자.

# 로직 추론 과정은 다음과 같다.
# 1. 한자리는 1~9 각 9개이다
# 2. 두번째 자리는 각 숫자에서 한자리 숫자로 시작하는 숫자들의 가능성을 모두 더한다.
# 3. 1, 2, 3 ... 각각은 0으로 시작 2로 시작 / 1로 시작 + 3으로 시작 / 2로 시작 + 4로 시작 ... / 8 로 시작하는
#    한 자릿수 아래 수를 생성하는 수 의 방법을 모두 더하면 된다. (0을 포함하는 것도 이러한 이유이다. / 9는 시작하는 수가 8밖에 없으므로 
#                                                                                             얘는 8의 경우의 수만 더하자.
# 이를 코드화 시키면 아래와 같다.
# ===================================================

N = int(input())

# 버그 있는 경우 그냥 끝
if (N <1 or N > 100):
    exit(1)
    
def sum(arr):
    result = 0;
    for i in range(1, 10): # 0의 경우는 케이스를 제외한다.
        result += arr[i]
        
    return result % 1000000000
    

dp = [[1 for i in range(10)]for _ in range(100)]

for i in range(1, 100):
    for j in range(10):
        # 0인 경우는 1로 시작하는 모든 경우의 수이다. << 이는 다음 dp[i+1][1] 계산에서, 1 다음으로 올 수 잇는 수가 0 또는 1이기에
        # 꼭 적어줘야 한다.
        if (j == 0): 
            dp[i][j] = dp[i-1][1]
            if (dp[i][j] > 1000000000):
                dp[i][j] %= 1000000000
            continue
        if(j == 9):
            dp[i][j] = dp[i-1][8]
            if (dp[i][j] > 1000000000):
                dp[i][j] %= 1000000000
            break
        dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1];
        if (dp[i][j] > 1000000000):
            dp[i][j] %= 1000000000
        
print(sum(dp[N-1]))

